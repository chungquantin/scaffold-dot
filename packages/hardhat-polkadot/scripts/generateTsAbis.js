/**
 * DON'T MODIFY OR DELETE THIS SCRIPT (unless you know what you're doing)
 *
 * This script generates the file containing the contracts Abi definitions.
 * These definitions are used to derive the types needed in the custom scaffold-eth hooks, for example.
 * This script should run as the last deploy script.
 */

const fs = require("fs");
const prettier = require("prettier");

const generatedContractComment = `
/**
 * This file is autogenerated by Scaffold-ETH.
 * You should not edit it manually or your changes might be overwritten.
 */
`;

const DEPLOYMENTS_DIR = "./deployments";
const ARTIFACTS_DIR = "./artifacts";

function getDirectories(path) {
  return fs
    .readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
}

function getContractNames(path) {
  return fs
    .readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isFile() && dirent.name.endsWith(".json"))
    .map(dirent => dirent.name.split(".")[0]);
}

function getActualSourcesForContract(sources, contractName) {
  for (const sourcePath of Object.keys(sources)) {
    const sourceName = sourcePath.split("/").pop()?.split(".sol")[0];
    if (sourceName === contractName) {
      const contractContent = sources[sourcePath].content;
      const regex = /contract\s+(\w+)\s+is\s+([^{}]+)\{/;
      const match = contractContent.match(regex);

      if (match) {
        const inheritancePart = match[2];
        // Split the inherited contracts by commas to get the list of inherited contracts
        const inheritedContracts = inheritancePart.split(",").map(contract => `${contract.trim()}.sol`);

        return inheritedContracts;
      }
    }
  }
  return [];
}

function getInheritedFunctions(sources, contractName) {
  const inheritedContracts = getActualSourcesForContract(sources, contractName);
  const allFunctions = new Set();

  for (const contract of inheritedContracts) {
    const contractName = contract.replace(".sol", "");
    const contractPath = `${ARTIFACTS_DIR}/contracts/${contractName}.sol/${contractName}.json`;
    
    if (fs.existsSync(contractPath)) {
      const contractJson = JSON.parse(fs.readFileSync(contractPath, "utf8"));
      if (contractJson.abi) {
        contractJson.abi
          .filter(item => item.type === "function")
          .forEach(func => {
            allFunctions.add(func.name);
          });
      }
    }
  }

  return Array.from(allFunctions);
}

function getContractDataFromDeployments() {
  const allChains = getDirectories(DEPLOYMENTS_DIR);
  const allContracts = {};

  allChains.forEach(chainId => {
    const chainIdDir = `${DEPLOYMENTS_DIR}/${chainId}`;
    const files = getContractNames(chainIdDir);
    
    files.forEach(file => {
      const deployment = JSON.parse(fs.readFileSync(`${chainIdDir}/${file}.json`, "utf8"));
      allContracts[file] = allContracts[file] || {};
      allContracts[file][chainId] = deployment;
    });
  });

  return allContracts;
}

// Generates the TypeScript contract definition file based on the json output of the contract deployment scripts
// This script should be run last.
async function generateTsAbis() {
  const allContractsData = getContractDataFromDeployments();
  const fileContent = Object.entries(allContractsData).map(([contractName, chains]) => {
    const chainsOutput = Object.entries(chains)
      .map(([chainId, contractData]) => {
        return `    ${chainId}: {
      address: "${contractData.address}",
      abi: ${JSON.stringify(contractData.abi, null, 2).replace(/\n/g, '\n      ')},
      inheritedFunctions: ${JSON.stringify(contractData.inheritedFunctions || [], null, 2).replace(/\n/g, '\n      ')}
    }`;
      })
      .join(",\n");

    return `export const ${contractName} = {
${chainsOutput}
};`;
  }).join("\n\n");

  const prettierConfig = await prettier.resolveConfig("./");
  const formattedContent = await prettier.format(
    `${generatedContractComment}\n${fileContent}`,
    {
      ...prettierConfig,
      parser: "typescript",
    }
  );

  const dir = "./contracts";
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  fs.writeFileSync(
    "contracts/deployedContracts.ts",
    formattedContent,
    { flag: "w" }
  );
  console.log("üìù Updated TypeScript contract definitions");
}

module.exports = generateTsAbis;
